<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EBFT: An Equal Algorithm Simplifying BFT Consensus</title>
    <style>
        body {
            font-family: 'Helvetica Neue', sans-serif;

            margin: auto;
            width: 800px;
            padding: 0;

            line-height: 1.6;
            font-size: 18px;
            /* è®¾ç½®é»˜è®¤å­—ä½“å¤§å°ä¸º18px */

            background-color: #6d695c;
            background-image:
                repeating-linear-gradient(120deg, rgba(255, 255, 255, .1), rgba(255, 255, 255, .1) 1px, transparent 1px, transparent 60px),
                repeating-linear-gradient(60deg, rgba(255, 255, 255, .1), rgba(255, 255, 255, .1) 1px, transparent 1px, transparent 60px),
                linear-gradient(60deg, rgba(0, 0, 0, .1) 25%, transparent 25%, transparent 75%, rgba(0, 0, 0, .1) 75%, rgba(0, 0, 0, .1)),
                linear-gradient(120deg, rgba(0, 0, 0, .1) 25%, transparent 25%, transparent 75%, rgba(0, 0, 0, .1) 75%, rgba(0, 0, 0, .1));
            background-size: 70px 120px;
        }

        .container {

            margin: 0 auto;
            padding: 30px;
            background-color: #eeeeee;
            /* è®¾ç½®èƒŒæ™¯é¢œè‰²ä¸ºæµ…è“è‰² */
        }

        h1 {
            color: #000000;
            text-align: center;
            padding: 0px 0;
            font-size: 1.5rem;
            /* è°ƒæ•´æ ‡é¢˜å­—ä½“å¤§å° */
            font-weight: bold;
        }

        h2,
        h3 {
            color: #000000;
            margin: 20px 0 10px;
            font-size: 1.3rem;
            /* è°ƒæ•´å‰¯æ ‡é¢˜å­—ä½“å¤§å° */
        }

        p,
        ul {
            color: #000000;
            font-size: 0.9rem;
            /* è°ƒæ•´æ®µè½å­—ä½“å¤§å° */
            text-align: justify;
        }

        ul {
            margin-left: 10px;
        }

        *-- header {
            background-color: #f8f9fa;
            padding: 5px;
            border-bottom: 1px solid #000000;

        }

        nav ul {
            list-style-type: none;
            margin: 0;
            padding: 0;
            overflow: hidden;
            border-bottom: 1px solid #000000;

        }

        nav li {
            float: left;
        }

        nav li a {
            display: block;
            color: black;
            text-align: center;
            padding: 7px 8px;
            text-decoration: underline;
        }

        nav li a:hover {
            background-color: #ddd;
        }

        .codeBlock {
            background-color: #8a8787;
            border-style: solid;
            border-width: 1px;
            border-color: #000000;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            margin-left: 20px;
            margin-right: 20px;
        }

        .annotation {
            color: #34353c;
        }

        #floatingMenu {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: #baa7a7;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        #floatingMenu a {
            text-decoration: none;
            color: #000;
            font-size: 0.8rem;
            cursor: pointer;

        }

        #floatingMenu a:hover {
            text-decoration: none;
            color: #d0c3c3;
            font-size: 0.7rem;
            cursor: pointer;

        }

        .submenu {
            display: none;
            list-style-type: none;
            padding-left: 20px;
            margin: 0;
        }

        .submenu ul li {
            list-style: none;
            margin-top: 3px;
        }

        #floatingMenu li {
            list-style: none;
            margin-top: 3px;
        }
    </style>
    <script>
        function toggleSubmenu(id) {
            var submenu = document.getElementById(id);
            if (submenu.style.display == "block") {
                submenu.style.display = "none";
            } else {
                submenu.style.display = "block";
            }
        }
    </script>
</head>

<body>
    <!-- <div id="floatingMenu">
            <li><a href="#title" onclick="toggleSubmenu('submenu1')">Title</a>
                <ul id="submenu1" class="submenu">
                    <li><a href="#section1-1">ç¬¬ä¸€éƒ¨åˆ† - å­éƒ¨åˆ†1</a></li>
                    <li><a href="#section1-2">ç¬¬ä¸€éƒ¨åˆ† - å­éƒ¨åˆ†2</a></li>
                </ul>
            </li>
            <li><a href="#submenu2.1" >Design of the EBFT Algorithm</a>
            </li>
            <li><a  onclick="toggleSubmenu('submenu2')">EBFT-Syn</a>
                <ul id="submenu2" class="submenu">
                    <li><a href="#section2-1">Blocks and block format</a></li>
                    <li><a href="#section2-2">Vote and certificate</a></li>
                    <li><a href="#section2-3">Block chaining and ranking</a></li>
                    <li><a href="#section2-4">Block producing</a></li>
                    <li><a href="#section2-5">Block processing</a></li>
                    <li><a href="#section2-6">Vote processing</a></li>
                    <li><a href="#section2-7">Timer interrupt processing</a></li>
                    <li><a href="#section2-8">Pseudocode of EBFT-Syn</a></li>
                </ul>
            </li>
            <li><a onclick="toggleSubmenu('submenu3')">EBFT-PSyn</a>
                <ul id="submenu3" class="submenu">
                    <li><a href="#section3-1">Blockchain Structure</a></li>
                    <li><a href="#section3-2">Block processing</a></li>
                    <li><a href="#section3-3">Vote processing</a></li>
                    <li><a href="#section3-4">Pseudocode of EBFT-Syn</a></li>
                </ul> 
            </li>

            <li><a href="#section4" onclick="toggleSubmenu('submenu4')">EBFT-Turbo</a>
            </li>
            <li><a href="#section5" onclick="toggleSubmenu('submenu5')">Implementation and Evaluation of the EBFT Algorithm</a>
            </li>
            <li><a href="#section6" onclick="toggleSubmenu('submenu5')">Other work</a>
            </li>
    </div> -->
    <div class="container">
        <header>
            <nav>
                <ul>
                    <li><a href="https://arxiv.org/abs/2012.01636">Home</a></li>
                    <li><a href="https://teecertlabs.com/team/">About</a></li>
                </ul>
            </nav>
        </header>

        <h1 id="title">EBFT: An Equal Algorithm Simplifying BFT Consensus</h1>
        <p>The byzantine fault tolerant (BFT) consensus abstraction ensures the consistency among correct (non-faulty)
            instances even if some instances are byzantine (faulty, incorrect). The correct instances all decide on the
            same consensus value, whereas byzantine instances may exhibit arbitrary behaviour.</p>
        <p>We propose EBFT, a simplified BFT consensus framework that consists of three protocols: EBFT-Syn, EBFT-PSyn,
            and EBFT-Turbo12. These protocols adopt an egalitarian block production strategy that does not rely on a
            leader, but instead allows nodes to randomly propose blocks by solving cryptographic lotteries. This design
            enables the protocols to resist attacks targeting the leader, such as bribery attacks and targeted denial of
            service attacks, and eliminates the need for complex subprotocols to detect and replace faulty leaders.</p>
        <p>EBFT has the following features:</p>
        <ul>
            <li><strong>Equal block generation</strong>: All nodes can generate blocks through cryptographic lottery,
                not relying on the leader.</li>
            <li><strong>Longest certification chain rule</strong>: Nodes vote and generate blocks according to the
                longest certification chain rule, thereby ensuring the security and consistency of the blockchain.</li>
            <li><strong>Deterministic security and liveness</strong>: Nodes deterministically submit blocks by detecting
                convergence opportunities, without waiting for probabilistic confirmation.</li>
        </ul>
        <h2 id="submenu2.1">Design of the EBFT Algorithm</h2>
        <p>The EBFT algorithm includes three protocols: EBFT-Syn, EBFT-PSyn, and EBFT-Turbo, which are applicable to
            synchronous networks and partially synchronous networks respectively. Below we introduce the design of these
            three protocols.</p>
        <h3 id="submenu2">EBFT-Syn</h3>
        <p>EBFT-Syn is a BFT protocol suitable for synchronous networks, requiring the majority of nodes to be honest.
            It mainly includes the following three components:</p>
        <ul>
            <li"><strong>Equal block generation</strong>: Nodes compete to generate blocks through cryptographic
                lottery, and each node has the opportunity to become a block generator.</li>
                <li"><br/><br/><strong>Longest certification chain rule</strong>: After a node receives a valid block, if the
                    block extends the longest certification chain in the local view, it will vote for the block. A block
                    is certified if it receives at least ğ‘“ + 1 votes from nodes, where ğ‘“ is the number of Byzantine
                    nodes. Nodes always generate blocks at the end of the longest certification chain.</li>
                    <li"><br/><br/><strong>3Î” commit timer</strong>: After a node receives a valid block that extends the longest
                        certification chain, it sets a 3Î” timer, where Î” is the upper bound of network delay. If before
                        the timer expires, the node does not receive any blocks conflicting with this block, then this
                        is a convergence opportunity, and the node will commit this block and all uncommitted ancestor
                        blocks. In the synchrony model, a message sent at time ğ‘¡ by a node
                        will be received by another node before time ğ‘¡ + Î”. The duration of 3Î” is to ensure that
                        honest nodes can detect any conflicting blocks, by which they can
                        commit certified blocks that are unique at their heights. When a
                        node observes a block that extends the longest certified chain at
                        the time ğ‘¡, it then forwards the block to all other nodes. Others will
                        receive the block by time ğ‘¡ + Î”, and then honest nodes' votes will
                        arrive at all nodes by time ğ‘¡ + 2Î”. Hence, the block will be certified
                        by time ğ‘¡ + 2Î”. If any honest node votes for a conflicting block, it
                        must do so before ğ‘¡ + 2Î” (by LCCR). As a result, nodes will receive
                        the conflicting block by ğ‘¡ + 3Î”.</li>
        </ul>


        <p id="section2-4"><strong>Block producing.</strong>Nodes participate in the cryptographic lottery to win the chance of producing blocks. The parent block of this block will be the highest block the node sees.
        </p>
        <p id="section2-5"><strong>Block processing.</strong> Upon receiving a block, a node first assesses its validity. For valid blocks, if they conflict with existing block heights, the node cancels any existing timers associated with that height. If no conflict occurs, the node adds a timer for that block height. Honest nodes generate a vote for blocks that extend the longest chain and broadcast this vote to other nodes while forwarding the block.</p>
        <p id="section2-6"><strong>Vote processing.</strong> When a node collects votes for a block, it calculates the total number of votes received. If the vote count exceeds f+1, the block is certified, and the node updates the current highest certified block. </p>
        <p id="section2-7"><strong>Timer interrupt processing.</strong> When a blockâ€™s timer is triggered,
            the node commits this block together with all its non-committed
            ancestor blocks.</p>
        <!-- <p id="section2-8">The pseudocode of EBFT-Syn is as follows:</p>
        <pre class="codeBlock">
    <code>
    1: ğ‘€ â† {G0 }            <span class="annotation">âŠ² the set of blocks</span>
    2: ğ‘‰ â† {ğ‘„ğ¶0 }           <span class="annotation">âŠ² mapping votes with blocks</span>
    3: ğ¹ â† {G0 }             <span class="annotation">âŠ² the set of committed blocks</span>
    4: ğµâ€² â† G0              <span class="annotation">âŠ² the highest certified block</span>
    5: (ğ‘ğ‘˜, ğ‘ ğ‘˜)              <span class="annotation"> âŠ² the key pair of a node</span>
    6: upon event âŸ¨Lottery-Win|ğµâŸ© do
    7: ProduceBlock()          <span class="annotation">âŠ² producing blocks</span>
    8: upon event âŸ¨Block-Deliver|ğµâŸ© do
    9: ProcessBlock(ğµ)          <span class="annotation">âŠ² processing receiving block</span>
    10: upon event âŸ¨Vote-Deliver|ğ‘£âŸ© do
    11: ProcessVote(ğ‘£)          <span class="annotation">âŠ² processing receiving vote</span>
    12: upon event âŸ¨Timer-Interrupt|ğµâŸ© do
    13: ğ¹ â† ğ¹ âˆª GetAncestorBlocks(ğµ) âˆª {ğµ}   âŠ² committing blocks
    14: procedure ProduceBlock()
    15: ğµ.ğ‘‡ ğ‘¥ğ‘  â† GetTransactions()
    16: ğµ.â„ğ‘ â† H(ğµâ€²)            <span class="annotation">âŠ² parent blockâ€™s hash</span>
    17: ğµ.ğ‘„ğ¶ â† ğ‘‰ [ğµâ€²]           <span class="annotation">âŠ² parent blockâ€™s quorum certificate</span>
    18: ğµ.ğœŒ â† GetLotteryProof()
    19: ProcessBlock(ğµ)
    20: Broadcast(ğµ)
    21: procedure ProcessBlock(ğµ)
    22: if âˆƒğµ âˆˆ ğ‘€ then return
    23: if isValidNewBlock(ğµ) then
    24: ğ‘€ â† ğ‘€ âˆª {ğµ}         <span class="annotation">âŠ² already been stored</span>
    25: ProcessCommitTimer(ğµ)
    26: if isSatisfyingLCCR(ğµ) then
    27: ğœ â† Sig(ğ‘ ğ‘˜, H(ğµ))       <span class="annotation">âŠ² generating a signature</span>
    28: ğ‘£ â† (H(ğµ), ğ‘ğ‘˜, ğœ)       <span class="annotation">âŠ² generating a vote</span>
    29: ProcessVote(ğ‘£)
    30: Broadcast(ğµ, ğ‘£)
    31: procedure ProcessVote(ğ‘£)
    32: if {ğµ|ğµ âˆˆ ğ‘€ âˆ§ H(ğµ) = ğ‘£.â„ğ‘ğ‘ â„} = âˆ… then return
    33: if âˆƒğ‘£ âˆˆ ğ‘‰ [ğµ] then return
    34: ğ‘‰ [ğµ] â† ğ‘‰ [ğµ] âˆª {ğ‘£ }     <span class="annotation">âŠ² storing the vote</span>
    35: if |ğ‘‰ [ğµ] | â‰¥ ğ‘“ + 1 then
    36: ğµâ€² â† UpdateHighestCertifiedBlock()
    37: procedure ProcessCommitTimer(ğµ)
    38: ğ‘† â† {ğµâˆ—|ğµ â‰  ğµâˆ— âˆ§ ğµâˆ— .â„ğ‘’ğ‘–ğ‘”â„ğ‘¡ = ğµ.â„ğ‘’ğ‘–ğ‘”â„ğ‘¡ } <span class="annotation">âŠ² conflicting blocks</span>
    39: if ğ‘† = âˆ… then
    40: if isSatisfyingLCCR(ğµ) then SetTimer(ğµ, 3Î”)
    41: else then
    42: foreach ğµ âˆ— âˆˆ ğ‘† do CancelTimer(ğµâˆ—)</code>
        </pre> -->

        <h3>EBFT-PSyn</h3>
        <p>EBFT-PSyn is a BFT protocol suitable for partially synchronous networks, requiring less than one-third of the
            nodes to be Byzantine. It continues the equal block generation and longest certification chain rule in
            EBFT-Syn, but introduces two other components:</p>
        <ul>
            <li><strong>Commit blocks through uniqueness declarations</strong>: If a block has not received any
                conflicting blocks before it is received and certified by a node, then this block is locally unique and
                certified. When a node has a locally unique and certified block, it will broadcast a uniqueness
                declaration of this block, indicating that it will no longer vote for other blocks of the same height.
                If a node receives at least 2ğ‘“ + 1 such declarations, then this is a convergence opportunity, and the
                node can commit this block and all uncommitted ancestor blocks.</li>
            <li><strong>Optimization: Pipelining declarations and block votes</strong>: To improve the efficiency of the
                protocol, a block's uniqueness declaration can be delayed until the voting process of its child block.
                Therefore, when voting for a block, there are two situations. If its parent block is uniquely certified,
                the node can send a vote that includes the uniqueness declaration of the parent block. Otherwise, its
                vote does not include a uniqueness declaration. To achieve this, we distinguish two types of votes:
                witness votes (witVote) and commit votes (comVote). When a block is certified by at least 2ğ‘“ + 1
                comVotes, the node can commit all ancestor blocks of this block.</li>
        </ul>
        <p id="section3-1"><strong> Blockchain Structure.</strong> EBFT-PSyn adopts the same block format and chain
            structure as these in EBFT-Syn. The slight difference
            lies in that there are two vote types and that a quorum certificate
            has to contain at least 2ğ‘“ + 1 distinct votes (rather than ğ‘“ + 1 votes).


        <p id="section3-2"><strong>Block processing. </strong>When receiving a block, the duplication and
            validity check is the same as that in Syn. The difference
            lies in the voting process for a block that satisfies the LCCR. In particular, if the node has voted for any other block
            at the same height as the blockâ€™s parent block, it sends a witVote
            and the hash of the previously voted block. Otherwise, it sends
            a comVote. Note that for each block, a node only votes once, but
            a node can vote for multiple blocks at the same height if they all
            satisfy LCCR.</p>
        <p id="section3-3"><strong>Vote processing.</strong>When receiving a vote, a node will store the
            vote and map the vote with the block. After that, if the associated
            block becomes certified with no less than 2ğ‘“ + 1 (regardless of the
            vote types), the node will update the highest certified block. Besides, if a block has
            no less than 2ğ‘“ + 1 comVotes, it will commit all non-committed
            ancestor blocks of this block, excluding this block. </p>
        <p id="section3-4">Since block producing is
            the same as that in the synchronous network, we do not introduce it here.</p>
            <!-- it here. The pseudocode of
            EBFT-PSyn are as follows</p>
        <pre class="codeBlock">
                    <code>
    1: ğ‘€ â† {G0}         <span class="annotation">âŠ² the set of blocks</span>
    2: ğ‘‰ â† {ğ‘„ğ¶0}        <span class="annotation">âŠ² mapping votes with blocks</span>
    3: ğ¹ â† {G0}         <span class="annotation">âŠ² the set of committed blocks</span>
    4: ğµ' â† G0          <span class="annotation">âŠ² the highest certified block</span>
    5: (ğ‘ğ‘˜, ğ‘ ğ‘˜)         <span class="annotation">âŠ² the key pair of a node</span>
    6: upon event âŸ¨Lottery-Win|ğµâŸ© do
    7: ProduceBlock()       <span class="annotation">âŠ² producing blocks</span>
    8: upon event âŸ¨Block-Deliver|ğµâŸ© do
    9: ProcessBlock(ğµ)          <span class="annotation">âŠ² processing receiving block</span>
    10: upon event âŸ¨Vote-Deliver|ğ‘£âŸ© do
    11: ProcessVote(ğ‘£)          <span class="annotation">âŠ² processing receiving vote</span>
    12: procedure ProduceBlock()
    13: ğµ.ğ‘‡ğ‘¥ğ‘  â† GetTransactions()
    14: ğµ.â„ğ‘ â† H(ğµâ€²)            <span class="annotation">âŠ² parent blockâ€™s hash</span>
    15: ğµ.ğ‘„ğ¶ â† ğ‘‰ [ğµâ€²]           <span class="annotation">âŠ² parent blockâ€™s quorum certificate</span>
    16: ğµ.ğœŒ â† GetLotteryProof()
    17: ProcessBlock(ğµ)
    18: Broadcast(ğµ)
    19: procedure ProcessBlock(ğµ)
    20: if âˆƒğµ âˆˆ ğ‘€ then return       <span class="annotation">âŠ² already been stored</span>
    21: if isValidNewBlock(ğµ) then
    22: ğ‘€ â† ğ‘€ âˆª {ğµ}
    23: if isSatisfyingLCCR(ğµ) then
    24: if isUniqueParentBlock(ğµ) then
    25: ğœ â† Sig(ğ‘ ğ‘˜, (H(ğµ), comVote))
    26: ğ‘£ â† (H(ğµ), ğ‘ğ‘˜, comVote, ğœ)
    27: else then âŠ² generating a comVote
    28: ğœ â† Sig(ğ‘ ğ‘˜, (H(ğµ), witVote))
    29: ğ‘£ â† (H(ğµ), ğ‘ğ‘˜, witVote, ğœ)
    30: ProcessVote(ğ‘£)
    31: Broadcast(ğ‘£)
    32: procedure ProcessVote(ğ‘£)
    33: if {ğµ|ğµ âˆˆ ğ‘€ âˆ§ H(ğµ) = ğ‘£.â„ğ‘ğ‘ â„} = âˆ… then return
    34: if âˆƒğ‘£ âˆˆ ğ‘‰ [ğµ] then return
    35: ğ‘‰ [ğµ] â† ğ‘‰ [ğµ] âˆª {ğ‘£ }    <span class="annotation">âŠ² storing the vote</span>
    36: if |ğ‘‰ [ğµ] | â‰¥ 2ğ‘“ + 1 then
    37: ğµâ€² â† UpdateHighestCertifiedBlock()
    38: if |ğ‘‰ [ğµ].comVote| â‰¥ 2ğ‘“ + 1 then
    39: ğ¹ â† ğ¹ âˆª GetAncestorBlock(ğµ)
</code>
              </pre> -->
        <h3 id="section4">EBFT-Turbo</h3>
        <p>EBFT-Turbo is a high-performance partially synchronous BFT protocol based on EBFT-PSyn. It improves system
            throughput and latency by using Bitcoin-NG's technology to separate transaction ordering and consensus.
            Specifically, EBFT-Turbo stipulates that once a node solves the cryptographic lottery, it can generate a
            fixed number of microblocks. These microblocks do not need to be voted on, but are directly certified. Only
            regular blocks need to be voted on and committed, thereby reducing communication overhead.</p>
        <h2>Implementation and Evaluation of the EBFT Algorithm</h2>
        <p>We implemented the EBFT algorithm based on the Go version of Bitcoin, btcd, and evaluated its performance on
            AWS. We implemented EBFT-Syn, EBFT-PSyn, and EBFT-Turbo with about 920 lines of code, which shows that their
            design is simple. Our evaluation results show that on a cluster composed of 256 geographically distributed
            nodes, EBFT-Turbo can achieve a throughput of 3.6k transactions per second and a latency of 8 seconds, which
            can meet the needs of many blockchain applications.</p>
        <h3 id="section5">Other Work</h3>
        <p>We have implemented <a href="http://luoqihang123.me">a visualization of the two protocols of EBFT</a> to help
            understand how EBFT works. If you want more details, go to the paper(<a
                href="https://arxiv.org/abs/2012.01636">EBFT: Simplifying BFT Consensus Through Egalitarianism</a>)</p>
    </div>
</body>

</html>